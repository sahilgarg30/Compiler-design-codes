/*
 *	COMPILER PROJECT- ERPLAG COMPILER
 *	Batch Number 74
 *	Bhuvnesh Jain : 2014A7PS028P
 *	Chirag Agarwal : 2014A7PS033P
 */

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include "lexerDef.h"
#include "lexer.h"
#include "parserDef.h"
#include "parser.h"
#include "symbolDef.h"
#include "symbolTable.h"

#define LIMIT 25

void printSep() 
{
	printf("\n***************************************************************************************\n");
}

int main(int argc, char * argv[])
{
	//Initialise the hash table for keywords
	hashTable table = initializeHashTable(31);
	FILE *fp = fopen("keywords.txt", "r");
	int type, option;	
	char input[21];
	while(~fscanf(fp, "%d %s", &type, input))
	{
		addKeyword(table, type, input);
	}
	fclose(fp);

	// Initialise the Grammer
	Grammar G = (Grammar)malloc(RULECNT*sizeof(gHead));
	G = createGrammar();
	findFirst(G);
	findFollow(G);
	createParseTable(G);

	while(1)
	{
		//Display the menu
		printf("\nERPLAG COMPILER MENU OPTIONS:\n");
		printf("1: For producing clean code by removal of comments.\n");
		printf("2: For printing the token list generated by the lexer.\n");
		printf("3: For printing the Symbol table.\n");
		printf("4: For parsing to verify the syntactic correctness of the input source code\n");
		printf("5: For creating the parsetree and printing it(inorder traversal)\n");
		printf("6: To exit.\n");
		int option;
		scanf("%d",&option);

		if(option == 1)
		{
			removeComments(argv[1],"cleancode.txt");
			printSep();
			printf("cleancode.txt created\n");
			printSep();
		}
		else if(option == 2)
		{
			printSep();
			int error_exist = populateLexemeTable(argv[1], table, 1);
			if (error_exist == 1)
			{
				printf("Recheck your code for Lexical errors\n");
			}
			printSep();
		}
		else if (option == 3)
		{
			removeComments(argv[1], "clean.txt");
			parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			tokenInfo *T = getFirstToken();
			hashTable2 tableId = initializeHashTable2(hash_capacity_2);
			hashTable2 tableFunc = initializeHashTable2(hash_capacity_2);
			totalScopeList* scopeTable = (totalScopeList *)malloc(LIMIT * sizeof(totalScopeList));
			int i;
			for(i = 0; i < LIMIT; ++i)
			{
				scopeTable[i].scope_start = 0;
				scopeTable[i].scope_end = 0;
			}
			createIDTable(T, scopeTable, tableId, tableFunc, 0);
			T = getFirstToken();
			secondRun(T, tableId, tableFunc, 0);
			printf("Symbol Table sucessfully created.\n");
			printf("%-4s %-10s\t%-20s %-10s %-15s %-6s %-6s %-6s\n", "SNO", "Var-Name", "Func-Name", "Datatype", "Start - End", "Level", "Size", "Offset");
			printVariables(tableId, scopeTable);
		}
		else if(option == 4)
		{
			removeComments(argv[1], "clean.txt");
			printSep();
			parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			printSep();
		}
		else if (option == 5)
		{
			removeComments(argv[1], "clean.txt");
			printSep();
			// parseTree Tree = parseInputSourceCode("clean.txt", table, G, 0);
			printParseTree("clean.txt", table, G);
			printf("\n");
			printSep();
		}
		else if (option == 6)
		{
			break;
		}
		else
		{
			printf("\nInvalid Option\n");
		}
	}
	return(0);	
}
